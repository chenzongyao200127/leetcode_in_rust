# 时间复杂度 O(n^2) 级排序算法

from typing import List

# 1.冒泡排序

# 题目描述
# 实现冒泡排序算法对一个整数数组进行排序，并返回排序后的数组。
# 冒泡排序是一种简单的排序算法，它重复地遍历待排序的数列，一次比较两个元素，若它们的顺序错误就把它们交换过来。
# 遍历数列的工作是重复进行直到没有再需要交换，也就是说该数列已经排序完成。

# 冒泡排序是入门级的算法，但也有一些有趣的玩法。通常来说，冒泡排序有三种写法：
# 一边比较一边向后两两交换，将最大值 / 最小值冒泡到最后一位；
# 经过优化的写法：使用一个变量记录当前轮次的比较是否发生过交换，如果没有发生交换表示已经有序，不再继续排序；
# 进一步优化的写法：除了使用变量记录当前轮次是否发生交换外，再使用一个变量记录上次发生交换的位置，下一轮排序时到达上次交换的位置就停止比较。
from pprint import pprint


# 想象一下，你有一排小球，这些小球在水桶里漂浮着，每个小球上都写了一个数字。
# 你的任务是把这些小球按照数字从小到大的顺序排列起来，让数字最小的小球在最左边，数字最大的小球在最右边。

# 这样做的方法是：
# 1. 从左边开始，比较第一个小球上的数字和第二个小球上的数字。如果第一个小球的数字比第二个大，就让它们两个交换位置。这样，较大的数字就会向右移动。
# 2. 然后，再比较第二个和第三个小球的数字，做同样的操作。这样继续下去，直到你比较到最后两个小球。
# 3. 完成一轮后，你会发现最大的数字已经在最右边的位置了，就像最大的气泡最后浮到水面上一样。
# 4. 下一轮，你再次从左边开始，重复同样的比较和交换的过程，但这次你可以少比较一次，因为最右边的最大数字已经在正确的位置了。
# 5. 重复这个过程，每次都少比较一次，直到所有的小球都排好序。

# 这个过程就像是小球在水中冒泡一样，较大的数字像气泡一样逐渐“冒”到正确的位置。
# 这就是为什么这种排序方法被称为“冒泡排序”。
# 每一轮比较都像是在帮每个小球找到它应该在的位置。

# 相关习题：283. 移动零
def bubble_sort(arr: List[int]) -> List[int]:
    n = len(arr)
    for i in range(n):
        already_sorted = True
        for j in range(1, n - i):
            if arr[j - 1] > arr[j]:
                arr[j], arr[j - 1] = arr[j - 1], arr[j]
                already_sorted = False
        if already_sorted:
            break
    return arr


def test_bubble_sort():
    assert bubble_sort([34, 7, 23, 32, 5, 62]) == [5, 7, 23, 32, 34, 62]
    assert bubble_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    assert bubble_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]
    assert bubble_sort([-1, -3, -2, 0, 2]) == [-3, -2, -1, 0, 2]
    assert bubble_sort([100]) == [100]
    assert bubble_sort([]) == []
    assert bubble_sort([3, 3, 3, 3]) == [3, 3, 3, 3]
    print("All test cases pass")


test_bubble_sort()

# ⭐ 冒泡排序的时间与空间复杂度
# 时间复杂度 O(n^2)
# 空间复杂度 O(1)

####################################################################################################


# 选择排序
# 选择排序的思想是：双重循环遍历数组，每经过一轮比较，找到最小元素的下标，将其交换至首位。
# 选择排序是一种简单直观的排序算法。
# 它的工作原理是这样的：算法遍历整个数组，多次选择其中最小的一个元素，然后将它放到正确的位置。
# 具体来说，每次遍历时，你从数组的未排序部分找出最小的元素，然后将这个最小元素交换到未排序部分的前端。这个过程重复进行，直到整个数组变得有序。


# 题目描述

# 实现选择排序算法对一个整数数组进行排序，并返回排序后的数组。
# 选择排序是一种简单的排序算法，它通过重复地选取未排序部分的最小（或最大）元素，然后与未排序部分的起始位置进行交换来逐渐将元素排序。

def selection_sort(arr: List[int]) -> List[int]:
    n = len(arr)
    for i in range(n-1):
        min_index = i
        for j in range(i+1, n):
            if arr[j] < arr[min_index]:
                min_index = j
        arr[i], arr[min_index] = arr[min_index], arr[i]
    return arr


def test_selection_sort():
    assert selection_sort([29, 10, 14, 37, 13]) == [10, 13, 14, 29, 37]
    assert selection_sort([4, 5, 3, 2, 1]) == [1, 2, 3, 4, 5]
    assert selection_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]
    assert selection_sort([-1, -3, -2, 0, 2]) == [-3, -2, -1, 0, 2]
    assert selection_sort([100]) == [100]
    assert selection_sort([]) == []
    assert selection_sort([3, 3, 3, 3]) == [3, 3, 3, 3]
    print("All test cases pass")


test_selection_sort()

# 稳定性验证


def selection_sort(arr):
    n = len(arr)
    for i in range(n-1):
        min_index = i
        for j in range(i+1, n):
            # 仅比较元素的值，不考虑标识符
            if arr[j][0] < arr[min_index][0]:
                min_index = j
        # 交换可能会打乱相同元素的原始顺序
        arr[i], arr[min_index] = arr[min_index], arr[i]
    return arr


# 元素格式为 (value, identifier)
input_arr = [(3, 'A'), (3, 'B'), (2, 'C')]
sorted_arr = selection_sort(input_arr)
print("Sorted array:", sorted_arr)

# ⭐ 选择排序的时间与空间复杂度
# 时间复杂度 O(n^2)
# 空间复杂度 O(1)


####################################################################################################

# 插入排序

# 给定一个整数数组 `nums`，编写一个函数对其进行插入排序，并返回排序后的数组。插入排序的算法描述是：
# 1. 从数组的第二个元素开始，逐个将未排序的元素插入到已排序的序列中适当的位置。
# 2. 对于每个未排序的元素，与已排序序列中的元素从后向前比较，找到相应的位置并插入。

# 插入排序是一种简单直观的排序算法，它的工作方式类似于我们整理手中扑克牌的过程。
# 想象一下你在打扑克牌，每次摸到一张新牌时，你会将它插入到手中已经排序好的牌中的适当位置，以确保你的手牌始终保持有序。
# 插入排序正是采用这样的方法来对数组进行排序。

# 插入排序的效率不如一些高级的排序算法（如快速排序、归并排序等），特别是在数据量大的情况下。
# 其平均和最坏情况的时间复杂度都是 O(n^2)，其中 n 是数组的长度。
# 然而，对于小数据量或基本有序的数据，插入排序的性能还是非常不错的。而且，它是一种稳定的排序算法，并且是在线的，可以逐个处理数据项。

def insertion_sort(nums):
    for i in range(1, len(nums)):
        key = nums[i]
        j = i - 1
        while j >= 0 and key < nums[j]:
            nums[j + 1] = nums[j]
            j -= 1
        nums[j + 1] = key

    return nums


def test_insertion_sort():
    # 测试用例 1
    assert insertion_sort([4, 3, 2, 10, 12, 1, 5, 6]) == [
        1, 2, 3, 4, 5, 6, 10, 12]
    # 测试用例 2
    assert insertion_sort([2, 1]) == [1, 2]
    # 测试用例 3
    assert insertion_sort([1]) == [1]
    # 测试用例 4
    assert insertion_sort([]) == []
    # 测试用例 5
    assert insertion_sort([5, -1, 3, -2, 8, 0]) == [-2, -1, 0, 3, 5, 8]
    print("所有测试用例通过")


test_insertion_sort()

# - **算法思路 **：插入排序通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
# 插入排序在实现上，通常使用`in -place`排序（即只需用到O(1)的额外空间的排序）。
# - **时间复杂度 **：最好情况 O(n)（数组已经是排序的），平均和最坏情况 O(n ^ 2)。
# - **空间复杂度 **：O(1)，因为是原地排序。

# 时间复杂度 O(nlogn) 级排序算法
