# 552_Student_Attendance_Record_II
# https://leetcode.cn/problems/student-attendance-record-ii/

# 可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：
# 'A'：Absent，缺勤
# 'L'：Late，迟到
# 'P'：Present，到场
# 如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：

# 按 总出勤 计，学生缺勤（'A'）严格 少于两天。
# 学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（'L'）记录。

# 给你一个整数 n ，表示出勤记录的长度（次数）。
# 请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 数量 。
# 答案可能很大，所以返回对 109 + 7 取余 的结果。


class Solution:
    def checkRecord(self, n: int) -> int:
        # 定义状态：dp[i][j][k] 表示前 i 天有 j 次 'A'，以及以 'L' 结尾且 'L' 的连续数量不超过 k 的方案数。
        MOD = 10**9 + 7
        dp = [[[0,0,0] for _ in range(2)] for _ in range(n+1)]
        dp[0][0][0] = 1
        for i in range(1, n+1):
            # 第 i 天出勤（'P'）
            for j in range(2):
                for k in range(3):
                    # 这种情况下，不论之前有没有 'A'，或者有多少个连续的 'L'，都可以在这一天出勤，
                    # 所以我们把之前的所有情况加起来就是这一天出勤的所有情况。
                    # 对应的代码就是对 j（0 或 1）和 k（0，1，2）所有可能的情况进行遍历，
                    # 并把之前的 dp[i-1][j][k] 加到 dp[i][j][0] 上。
                    dp[i][j][0] = (dp[i][j][0] + dp[i-1][j][k]) % MOD
            # 第 i 天缺席（'A'）    
            for k in range(3):
                # 这种情况下，之前不能有 'A'，所以我们需要把之前没有 'A' 的所有情况加起来，就是这一天缺席的所有情况。
                # 对应的代码就是对 k（0，1，2）所有可能的情况进行遍历，
                # 并把之前的 dp[i-1][0][k] 加到 dp[i][1][0] 上。
                dp[i][1][0] = (dp[i][1][0] + dp[i-1][0][k]) % MOD
            # 第 i 天迟到（'L'）
            for j in range(2):
                # 这种情况下，前一天不能是连续三天迟到，所以我们需要把之前连续迟到天数少于3的情况加起来，就是这一天迟到的所有情况。
                # 对应的代码就是对 j（0 或 1）和 k（1 或 2）进行遍历，并把之前的 dp[i-1][j][k-1] 加到 dp[i][j][k] 上。
                for k in range(1,3):
                    dp[i][j][k] = (dp[i][j][k] + dp[i-1][j][k-1]) % MOD
        
        res = 0
        for j in range(2):
            for k in range(3):
                res = (res + dp[n][j][k]) % MOD
                
        return res     
                    

class Solution:
    def checkRecord(self, n: int) -> int:
        MOD = 10**9 + 7
        # A 的数量，结尾连续 L 的数量
        dp = [[0, 0, 0], [0, 0, 0]]
        dp[0][0] = 1

        for i in range(1, n + 1):
            dpNew = [[0, 0, 0], [0, 0, 0]]

            # 以 P 结尾的数量
            for j in range(0, 2):
                for k in range(0, 3):
                    dpNew[j][0] = (dpNew[j][0] + dp[j][k]) % MOD
            
            # 以 A 结尾的数量
            for k in range(0, 3):
                dpNew[1][0] = (dpNew[1][0] + dp[0][k]) % MOD
            
            # 以 L 结尾的数量
            for j in range(0, 2):
                for k in range(1, 3):
                    dpNew[j][k] = (dpNew[j][k] + dp[j][k - 1]) % MOD
            
            dp = dpNew
        
        total = 0
        for j in range(0, 2):
            for k in range(0, 3):
                total += dp[j][k]
        
        return total % MOD
        
        



class Solution:
    def checkRecord(self, n: int) -> int:
        ax = [0] * (n+1)
        ax[0], ax[1], ax[2] = 1, 2, 4

        def f(n):
            for i in range(3, n+1):
                ax[i] = (ax[i-1] + ax[i-2] + ax[i-3]) % 1000000007
        f(n)
        
        # 这一行代码使用动态规划的思想计算出了长度为 i 的所有可能出勤记录的数量。

        # 要理解这个表达式的来源，首先需要明确出勤记录的规则：

        # 学生不能有超过一天的缺勤记录（"A"）。
        # 学生不能有连续三天或更多的迟到记录（"L"）。
        # 按照这些规则，我们可以推导出以下结论：

        # 长度为 i 的所有可能的出勤记录可以由以下三种情况构成：
        # 长度为 i-1 的所有可能的出勤记录后面加上一个 "P"。这种情况的数量就是长度为 i-1 的所有可能的出勤记录的数量，即 ax[i-1]。
        # 长度为 i-2 的所有可能的出勤记录后面加上 "PL"。这种情况的数量就是长度为 i-2 的所有可能的出勤记录的数量，即 ax[i-2]。
        # 长度为 i-3 的所有可能的出勤记录后面加上 "PLL"。这种情况的数量就是长度为 i-3 的所有可能的出勤记录的数量，即 ax[i-3]。
        # 将这三种情况的数量加起来就得到了长度为 i 的所有可能的出勤记录的数量。
        # 在这个过程中，我们使用了模运算 % 1000000007 来防止数字溢出，并确保结果在对 10^9 + 7 取余的结果范围内。
        # 因此，ax[i] = (ax[i-1] + ax[i-2] + ax[i-3]) % 1000000007 就表示了长度为 i 的所有可能的出勤记录的数量。

        num = ax[n]

        for i in range(n):
            num = (ax[i] * ax[n-i-1] + num) % 1000000007

        # 这个循环是为了处理出勤记录中缺勤一天的情况。因为学生可以缺勤一天，所以我们要考虑在出勤记录的任何位置插入一天的缺勤。
        # 因此，对于从0到n-1的每个i，我们都假设第i天是缺勤的，然后计算出所有可能的出勤记录的数量。这些可能的出勤记录可以分为两部分：
        # 在缺勤日之前的出勤记录，它的长度为i，所有可能的出勤记录的数量为ax[i]。
        # 在缺勤日之后的出勤记录，它的长度为n-i-1，所有可能的出勤记录的数量为ax[n-i-1]。
        # 在缺勤日之前和之后的出勤记录是独立的，所以所有可能的出勤记录的数量就是这两部分的乘积，即ax[i] * ax[n-i-1]。
        # 然后我们将这个乘积加到总的可能的出勤记录的数量num上，即num = (ax[i] * ax[n-i-1] + num) % 1000000007。
        # 这里使用了模运算% 1000000007来防止数字溢出，并确保结果在对10^9 + 7取余的结果范围内。
        # 因此，这个循环就是计算出包含一天缺勤的所有可能的出勤记录的数量，并将它们加到总的可能的出勤记录的数量上。
        
        
        return num

# 暂时不要求
from typing import list
# 这是一个矩阵快速幂的问题。主要利用的是状态转移的特性，将这些状态转移关系表示成一个矩阵，通过矩阵乘法可以得到n步后的状态分布。
# 然后用快速幂算法计算n次方矩阵，可以在对数时间内得到结果。

# 首先看mat，这个6x6的矩阵表示了所有状态的转移情况。
# 这里的状态被定义为：前一天的出勤情况（'A'的数量和连续'L'的数量），
# 所以一共有6种状态（列出来的话就是：P0L0，P0L1，P0L2，P1L0，P1L1，P1L2）。

# 然后定义了两个矩阵运算的函数：multiply和matrixPow。multiply实现了矩阵的乘法，matrixPow实现了矩阵的快速幂。

# 在checkRecord函数中，首先定义了转移矩阵mat，
# 然后通过matrixPow(mat, n)计算了n次方矩阵，
# 得到了n步后的状态分布。最后，将这个结果的所有元素求和并取模就得到了答案。

# matrixPow中的ret矩阵，一开始被初始化为单位矩阵。
# 在每次循环中，如果n是奇数，那么就将ret和mat相乘。
# 然后，无论n是奇数还是偶数，都要将mat自乘。
# 这是因为，在矩阵的乘法中，(A*B)^2=A^2*B^2不成立，只有A^2和B^2才能通过自乘得到。最后，把n右移一位，相当于将n除以2。

# 所以，这个解法的主要思想是将状态转移关系用矩阵表示，然后用矩阵的快速幂来快速计算n步后的状态分布。

# 这个6x6矩阵对应的是6种不同的状态：没有出现过'A'并且最近一次是'P'(标记为P0L0)，没有出现过'A'并且最近两次都是'L'(标记为P0L2)，没有出现过'A'并且最近一次是'L'(标记为P0L1)，出现过'A'并且最近一次是'P'(标记为P1L0)，出现过'A'并且最近一次是'L'(标记为P1L1)，出现过'A'并且最近两次都是'L'(标记为P1L2)。这些状态可以用一个三元组(i, j, k)表示，其中i表示出现'A'的次数，j表示最近连续出现'L'的次数，k表示是否出现过'A'。

# 那么，这个6x6的矩阵每一行每一列对应的都是这六种状态之一。
# 而矩阵中的元素表示的是从当前状态转移到下一个状态的方式有几种。
# 例如，从状态P0L0（未出现过'A'，最近一次是'P'）可以转移到自己（当天也是'P'），
# 也可以转移到状态P0L1（当天是'L'），还可以转移到状态P1L0（当天是'A'），所以矩阵中的第一行就是[1,1,0,1,0,0]。

# 具体的转移关系如下：

# 从P0L0可以转移到P0L0（当天是'P'），可以转移到P0L1（当天是'L'），也可以转移到P1L0（当天是'A'）。
# 从P0L1可以转移到P0L0（当天是'P'），可以转移到P0L2（当天是'L'）。
# 从P0L2只能转移到P0L0（当天是'P'）。
# 从P1L0可以转移到P1L0（当天是'P'），可以转移到P1L1（当天是'L'）。
# 从P1L1可以转移到P1L0（当天是'P'），可以转移到P1L2（当天是'L'）。
# 从P1L2只能转移到P1L0（当天是'P'）。
# 把这些关系对应到矩阵中，就得到了那个6x6的矩阵。

class Solution:
    def checkRecord(self, n: int) -> int:
        MOD = 10**9 + 7
        mat = [
            [1, 1, 0, 1, 0, 0],
            [1, 0, 1, 1, 0, 0],
            [1, 0, 0, 1, 0, 0],
            [0, 0, 0, 1, 1, 0],
            [0, 0, 0, 1, 0, 1],
            [0, 0, 0, 1, 0, 0],
        ]

        def multiply(a: list[list[int]], b: list[list[int]]) -> list[list[int]]:
            rows, columns, temp = len(a), len(b[0]), len(b)
            c = [[0] * columns for _ in range(rows)]
            for i in range(rows):
                for j in range(columns):
                    for k in range(temp):
                        c[i][j] += a[i][k] * b[k][j]
                        c[i][j] %= MOD
            return c

        def matrixPow(mat: list[list[int]], n: int) -> list[list[int]]:
            ret = [[1, 0, 0, 0, 0, 0]]
            while n > 0:
                if (n & 1) == 1:
                    ret = multiply(ret, mat)
                n >>= 1
                mat = multiply(mat, mat)
            return ret

        res = matrixPow(mat, n)
        ans = sum(res[0])
        return ans % MOD
