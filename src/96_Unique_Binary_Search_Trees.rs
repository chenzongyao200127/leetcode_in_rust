// 96_Unique_Binary_Search_Trees
// https://leetcode.cn/problems/unique-binary-search-trees/description/


// 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。

// 这段代码是Rust语言实现的，用于求解"不同的二叉搜索树"的数量，对应的问题是 LeetCode 中的 96 题。它是一道典型的动态规划问题。

// 首先，我们创建了一个动态规划数组 `dp`，长度为 `n+1`，初始化每个元素为0。`dp[i]` 表示由 `i` 个不同的节点组成的二叉搜索树的数量。
// `dp[0]` 和 `dp[1]` 都设置为 1，这是因为一个空树或者一个只有一个节点的树显然只有一种可能。
// 然后，我们遍历 `2` 到 `n` 的所有整数 `i`，对于每个 `i`，我们又遍历 `1` 到 `i` 的所有整数 `j`。`j` 表示在 `i` 个节点的树中，选择第 `j` 个节点作为根节点。
// 当我们确定了根节点 `j` 后，左子树包含的节点数量就是 `j-1` 个，右子树包含的节点数量就是 `i-j` 个。
// 由于二叉搜索树的性质，所有的左子树和右子树也都是二叉搜索树。
// 所以，左子树的数量可以从 `dp[j-1]` 中获取，右子树的数量可以从 `dp[i-j]` 中获取。
// 因此，由 `i` 个节点组成的，以 `j` 为根的二叉搜索树的数量就是 `dp[j-1] * dp[i-j]
// 我们将这个值累加到 `dp[i]` 中，最后 `dp[i]` 就表示由 `i` 个节点组成的所有可能的二叉搜索树的数量。
// 最后，返回 `dp[n]`，就是我们的答案。

impl Solution {
    pub fn num_trees(n: i32) -> i32 {
        let n = n as usize;
        let mut dp = vec![0; n + 1];
        dp[0] = 1;
        dp[1] = 1;

        for i in 2..=n {
            for j in 1..=i {
                dp[i] += dp[j-1] * dp[i-j];
            }
        }

        dp[n]
    }
}