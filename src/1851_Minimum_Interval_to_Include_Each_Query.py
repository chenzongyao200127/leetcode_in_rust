# 1851_Minimum_Interval_to_Include_Each_Query
# https://leetcode.cn/problems/minimum-interval-to-include-each-query/

# 给你一个二维整数数组 intervals ，
# 其中 intervals[i] = [lefti, righti] 表示第 i 个区间开始于 lefti 、结束于 righti（包含两侧取值，闭区间）。
# 区间的 长度 定义为区间中包含的整数数目，更正式地表达是 righti - lefti + 1 。

# 再给你一个整数数组 queries 。
# 第 j 个查询的答案是满足 lefti <= queries[j] <= righti 的 长度最小区间 i 的长度 。如果不存在这样的区间，那么答案是 -1 。

# 以数组形式返回对应查询的所有答案。

# Is there a way to order the intervals and queries such that it takes less time to query?
# Is there a way to add and remove intervals by going from the smallest query to the largest query to find the minimum size?

from typing import List

# 当我们对查询进行排序时，我们可以逐个处理每一个查询，每次都只考虑那些可以覆盖当前查询的区间。
# 首先，我们需要对区间进行排序，排序的依据是每个区间的左边界。然后，我们也需要对查询进行排序。
# 在开始查询之前，我们维护一个空的堆（优先级队列），用于存储当前所有可以覆盖查询的区间。
# 对于每个查询，我们添加所有开始位置小于等于当前查询值的区间到堆中，然后移除所有结束位置小于当前查询值的区间。
# 因此，每次查询时，堆中的区间都是可以覆盖当前查询的区间。堆顶的区间（长度最小的区间）就是我们要找的答案。

# 具体来说，这种策略的步骤如下：
# 对区间按照左边界进行排序。
# 对查询进行排序。
# 初始化一个空堆。
# 对于每个排序后的查询（从小到大）：
# 添加所有开始位置小于等于当前查询值的区间到堆中。这些区间都是可能覆盖当前查询的区间。
# 移除所有结束位置小于当前查询值的区间。这些区间都是无法覆盖当前查询的区间。
# 如果堆非空，那么堆顶的区间就是我们要找的答案，也就是覆盖当前查询的最小区间。否则，答案就是-1。
# 通过这种方式，我们可以在处理每个查询时，只关注那些可以覆盖当前查询的区间，避免了无效的搜索和比较。
# 同时，我们只需要对区间和查询进行一次排序，然后进行一次线性扫描，所以总体的时间复杂度是O((n+m)log(n+m))，其中n是区间的数量，m是查询的数量。
import heapq
from pprint import pprint


# 这道题并不需要高级数据结构，对于Python而言也不需要作弊~ 
# 由于区间和查询都是无序的，在线查询会难以处理。但考虑到题目给的区间是同时存在的，
# 没有“边查询边加区间”的现象，因此可以离线查询，将所有区间与查询的时间点分别排序，注意区间要按左端点来排序，这样就能保证对于每个查询，
# 当前的区间集合里至少都是左端点满足条件的。由于我们需要找最短的区间，因此当前的“区间集合”应该用最小堆（即优先队列）来存储，
# 并把关键字设为区间长度。每次查询前，先把左端点满足条件的所有区间都加入最小堆，然后返回长度最小的一个。

# 但这里还有个问题，当前区间集合里最短的区间，很有可能右端点也小于查询值，
# 这时查询值并不在这个区间，也就是说堆顶存了个“垃圾数据”。注意到查询已经按时间顺序排好了，当前堆顶的“垃圾数据”，
# 以后也是用不上的（以后的查询时间值只会更大，堆顶这个右端点会离查询时间越来越远），
# 所以把堆顶数据移出去就好，直到堆顶不是“垃圾数据”或者堆已经空了为止。
# 这就是所谓的“延迟删除”，在LC上有很多题目用到这个技巧（如同一周的双周赛83和周赛303的第三题重复，Python如果不作弊，就需要这个技巧）。

class Solution:
    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:
        intervals.sort(key = lambda x: (x[0], x[1])) # 按照左边界和区间长度排序
        q = sorted([(x, i) for i, x in enumerate(queries)]) # 将查询和原始索引一起排序
        heap = []
        res = [-1] * len(queries)
        j = 0
        for qi, i in q:
            while j < len(intervals) and intervals[j][0] <= qi:
                heapq.heappush(heap, (intervals[j][1] - intervals[j][0] + 1, intervals[j][1])) # 将区间长度和右边界一起放入堆中
                j += 1
            while heap and heap[0][1] < qi: # 移除所有无法覆盖当前查询的区间
                heapq.heappop(heap)
            if heap: # 如果还有可以覆盖当前查询的区间，那么堆顶的区间就是长度最小的区间
                res[i] = heap[0][0]
        return res

# 这段话的主要内容是解释了如何使用排序和优先队列（最小堆）来解决这个问题，
# 以及如何处理一种特殊情况——堆顶区间的右端点小于查询值，也就是查询值并不在这个区间。

# 首先，这段话提到，由于所有的区间和查询在开始时就已经全部给出，不存在在处理查询的过程中动态添加区间的情况，
# 所以我们可以使用离线查询的策略。离线查询就是先对查询进行排序，然后再按照顺序逐个处理每个查询。

# 对于每个查询，我们需要找出所有左端点满足条件的区间，然后在这些区间中找出长度最短的区间。
# 这里使用了一个数据结构——最小堆（或优先队列）。
# 最小堆是一种特殊的树形数据结构，其中每个父节点小于或等于其子节点，所以最小值总是在堆顶。
# 我们把所有左端点满足条件的区间加入最小堆，然后堆顶的区间就是长度最短的区间。

# 然而，这里有一个问题。即使堆顶的区间是长度最短的，但它的右端点可能小于查询值，也就是查询值并不在这个区间。
# 这时，我们不能直接返回堆顶的区间，因为它并不能覆盖当前的查询。
# 但由于我们已经对查询进行了排序，后续的查询值只会更大，所以这个区间以后也不会被用到，因此我们可以直接把它从堆中移除。
# 这就是所谓的“延迟删除”技巧。

# 在实际的代码实现中，这个过程可以通过一个while循环来完成。
# 在每次处理查询前，我们先把所有左端点满足条件的区间加入最小堆，
# 然后不断从堆顶移除那些右端点小于查询值的区间，直到堆顶不是“垃圾数据”（也就是右端点大于或等于查询值的区间）或者堆已经空了为止。
# 然后，如果堆非空，堆顶的区间就是我们要找的答案，否则，答案就是-1。


# 在线查询和离线查询是处理查询问题的两种策略，它们的区别主要在于查询的处理方式和时机：

# 在线查询（Online Querying）：在线查询是指查询在产生后立即进行处理，也就是说，查询和处理过程是实时进行的。
# 在线查询的特点是查询数据实时更新，需要即时响应，这也意味着对于查询处理的效率要求更高。
# 例如，搜索引擎在用户输入关键词后立即返回搜索结果就是在线查询。

# 离线查询（Offline Querying）：离线查询是指在所有查询都提前给定之后，再统一进行处理。
# 也就是说，查询的产生和处理过程是分离的。
# 离线查询的特点是可以预先知道所有的查询，这使得我们有可能对查询进行预处理，
# 比如排序或者建立索引，以提高查询处理的效率。例如，我们在处理一批数据库的查询请求时，
# 可能会先对所有的查询按照某种规则进行排序，然后再依次处理，这就是离线查询。

# 在处理具体问题时，我们会根据问题的特点和需求来选择使用在线查询还是离线查询。
# 例如，如果查询需要实时响应，那么就应该使用在线查询；而如果所有查询在开始时就已经全部给出，
# 那么我们就可以使用离线查询，进行一些预处理来提高查询处理的效率。


# print(minInterval(intervals = [[4,5],[5,8],[1,9],[8,10],[1,6]], queries = [7,9,3,9,3]))
# print(minInterval(intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]))

# [4,3,6,3,6]

# 1_Minimum_Interval_to_Include_Each_Query.py
# [[1, 8], [2, 5], [2, 3], [20, 25]]
# [(2, 0), (5, 2), (19, 1), (22, 3)]
# [(8, 8)]
# [(5, 4), (8, 8)]
# [(3, 2), (8, 8), (5, 4)]
# [(25, 6)]

# [(4, 4)]
# [(4, 3), (4, 4)]
# [(4, 3), (4, 4), (6, 4)]
# [(4, 1), (4, 3), (6, 4), (4, 4)]