# 675_Cut_Off_Trees_for_Golf_Event
# https://leetcode.cn/problems/cut-off-trees-for-golf-event/

# ä½ è¢«è¯·æ¥ç»™ä¸€ä¸ªè¦ä¸¾åŠžé«˜å°”å¤«æ¯”èµ›çš„æ ‘æž—ç æ ‘ã€‚æ ‘æž—ç”±ä¸€ä¸ª m x n çš„çŸ©é˜µè¡¨ç¤ºï¼Œ åœ¨è¿™ä¸ªçŸ©é˜µä¸­ï¼š

# 0 è¡¨ç¤ºéšœç¢ï¼Œæ— æ³•è§¦ç¢°
# 1 è¡¨ç¤ºåœ°é¢ï¼Œå¯ä»¥è¡Œèµ°
# æ¯” 1 å¤§çš„æ•° è¡¨ç¤ºæœ‰æ ‘çš„å•å…ƒæ ¼ï¼Œå¯ä»¥è¡Œèµ°ï¼Œæ•°å€¼è¡¨ç¤ºæ ‘çš„é«˜åº¦
# æ¯ä¸€æ­¥ï¼Œä½ éƒ½å¯ä»¥å‘ä¸Šã€ä¸‹ã€å·¦ã€å³å››ä¸ªæ–¹å‘ä¹‹ä¸€ç§»åŠ¨ä¸€ä¸ªå•ä½ï¼Œå¦‚æžœä½ ç«™çš„åœ°æ–¹æœ‰ä¸€æ£µæ ‘ï¼Œé‚£ä¹ˆä½ å¯ä»¥å†³å®šæ˜¯å¦è¦ç å€’å®ƒã€‚

# ä½ éœ€è¦æŒ‰ç…§æ ‘çš„é«˜åº¦ä»Žä½Žå‘é«˜ç æŽ‰æ‰€æœ‰çš„æ ‘ï¼Œæ¯ç è¿‡ä¸€é¢—æ ‘ï¼Œè¯¥å•å…ƒæ ¼çš„å€¼å˜ä¸º 1ï¼ˆå³å˜ä¸ºåœ°é¢ï¼‰ã€‚

# ä½ å°†ä»Ž (0, 0) ç‚¹å¼€å§‹å·¥ä½œï¼Œè¿”å›žä½ ç å®Œæ‰€æœ‰æ ‘éœ€è¦èµ°çš„æœ€å°æ­¥æ•°ã€‚ å¦‚æžœä½ æ— æ³•ç å®Œæ‰€æœ‰çš„æ ‘ï¼Œè¿”å›ž -1 ã€‚

# å¯ä»¥ä¿è¯çš„æ˜¯ï¼Œæ²¡æœ‰ä¸¤æ£µæ ‘çš„é«˜åº¦æ˜¯ç›¸åŒçš„ï¼Œå¹¶ä¸”ä½ è‡³å°‘éœ€è¦ç å€’ä¸€æ£µæ ‘ã€‚

from collections import defaultdict, deque
from typing import List
from pprint import pprint

# è¿™ä¸ªé—®é¢˜å¯ä»¥ç”¨ä¼˜å…ˆé˜Ÿåˆ—+å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰æ¥è§£å†³ã€‚æˆ‘ä»¬é¦–å…ˆéåŽ†æ•´ä¸ªçŸ©é˜µï¼Œ
# æŠŠæ‰€æœ‰çš„æ ‘ï¼ˆå³å¤§äºŽ1çš„å€¼ï¼‰ä»¥åŠå®ƒä»¬çš„ä½ç½®æ”¾åˆ°ä¸€ä¸ªä¼˜å…ˆé˜Ÿåˆ—ä¸­ï¼Œå¹¶æŒ‰æ ‘çš„é«˜åº¦è¿›è¡ŒæŽ’åºã€‚

# ç„¶åŽï¼Œæˆ‘ä»¬ä»Ž(0, 0)å¼€å§‹ï¼Œæ¯æ¬¡éƒ½ä»Žä¼˜å…ˆé˜Ÿåˆ—ä¸­å–å‡ºä¸€æ£µæ ‘ï¼ˆå³é˜Ÿé¦–å…ƒç´ ï¼Œå› ä¸ºé˜Ÿåˆ—å·²ç»æŒ‰æ ‘çš„é«˜åº¦æŽ’åºäº†ï¼‰ã€‚
# ç„¶åŽæˆ‘ä»¬ä½¿ç”¨BFSæ‰¾åˆ°å½“å‰ä½ç½®åˆ°è¿™æ£µæ ‘çš„æœ€çŸ­è·¯å¾„ï¼ŒæŠŠè·¯å¾„é•¿åº¦ç´¯åŠ åˆ°ç»“æžœä¸­ï¼Œå¹¶æŠŠå½“å‰ä½ç½®ç§»åŠ¨åˆ°è¿™æ£µæ ‘çš„ä½ç½®ã€‚

# å¦‚æžœåœ¨æŸä¸€æ­¥æˆ‘ä»¬æ‰¾ä¸åˆ°åˆ°è¾¾ä¸‹ä¸€æ£µæ ‘çš„è·¯å¾„ï¼ˆå³BFSè¿”å›ž-1ï¼‰ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±è¿”å›ž-1è¡¨ç¤ºæ— æ³•ç å®Œæ‰€æœ‰çš„æ ‘ã€‚
# å¦åˆ™ï¼Œåœ¨ç å®Œæ‰€æœ‰çš„æ ‘åŽï¼Œæˆ‘ä»¬è¿”å›žç»“æžœå³ä¸ºæ‰€æ±‚çš„æœ€å°æ­¥æ•°ã€‚

# è¿™ä¸ªé—®é¢˜çš„ä¸»è¦éš¾ç‚¹åœ¨äºŽï¼Œæˆ‘ä»¬éœ€è¦åœ¨æ¯ä¸€æ­¥éƒ½æ‰¾åˆ°å½“å‰ä½ç½®åˆ°ä¸‹ä¸€æ£µæ ‘çš„æœ€çŸ­è·¯å¾„ï¼Œè¿™éœ€è¦æˆ‘ä»¬åœ¨æ¯ä¸€æ­¥éƒ½è¿›è¡Œä¸€æ¬¡BFSã€‚
# åŒæ—¶ï¼Œç”±äºŽæˆ‘ä»¬éœ€è¦æŒ‰ç…§æ ‘çš„é«˜åº¦é¡ºåºç æ ‘ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦å¯¹æ‰€æœ‰çš„æ ‘è¿›è¡ŒæŽ’åºï¼Œè¿™å°±éœ€è¦ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ã€‚

# ä¸‹é¢æ˜¯è§£å†³è¿™ä¸ªé—®é¢˜çš„Pythonä»£ç ï¼š

from typing import List

def cutOffTree(forest: List[List[int]]) -> int:
    trees = sorted((v, r, c) for r, row in enumerate(forest) for c, v in enumerate(row) if v > 1)
    sr = sc = ans = 0

    def bfs(sr, sc, tr, tc):
        visited = [[False] * len(forest[0]) for _ in forest]
        visited[sr][sc] = True
        queue = [(sr, sc, 0)]
        for r, c, d in queue:
            if r == tr and c == tc:
                return d
            for nr, nc in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):
                if 0 <= nr < len(forest) and 0 <= nc < len(forest[0]) and not visited[nr][nc] and forest[nr][nc] != 0:
                    queue.append((nr, nc, d+1))
                    visited[nr][nc] = True
        return -1

    for _, tr, tc in trees:
        d = bfs(sr, sc, tr, tc)
        if d < 0: return -1
        ans += d
        sr, sc = tr, tc

    return ans


# A* ç®—æ³•
# ç”±äºŽé—®é¢˜çš„æœ¬è´¨æ˜¯æ±‚æœ€çŸ­è·¯ï¼ŒåŒæ—¶åŽŸé—®é¢˜çš„è¾¹æƒä¸º 1ï¼Œå› æ­¤å¥—ç”¨å…¶ä»–å¤æ‚åº¦æ¯” BFS é«˜çš„æœ€çŸ­è·¯ç®—æ³•ï¼Œ
# å¯¹äºŽæœ¬é¢˜è€Œè¨€æ˜¯æ²¡æœ‰æ„ä¹‰ï¼Œä½†è¿ç”¨å¯å‘å¼æœç´¢ AStar ç®—æ³•æ¥ä¼˜åŒ–åˆ™æ˜¯æœ‰æ„ä¹‰ã€‚

# å› ä¸ºåœ¨ BFS è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬ä¼šæ— å·®åˆ«å¾€ã€Œå››è”é€šã€æ–¹å‘è¿›è¡Œæœç´¢ï¼Œç›´åˆ°æ‰¾åˆ°ã€Œå½“å‰æ ‘ç‚¹çš„ä¸‹ä¸€ä¸ªç›®æ ‡ä½ç½®ã€ä¸ºæ­¢ï¼Œ
# è€Œå®žé™…ä¸Šï¼Œä¸¤ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„å¾€å¾€ä¸Žä¸¤ç‚¹ä¹‹é—´çš„ç›¸å¯¹ä½ç½®ç›¸å…³ã€‚

# ä¸¾ä¸ª ðŸŒ°ï¼Œå½“å‰æˆ‘ä»¬åœ¨ä½ç½® Sï¼Œæˆ‘ä»¬ç›®æ ‡ä½ç½®æ˜¯ Tï¼Œè€Œ T åœ¨ S çš„å³ä¸‹æ–¹ï¼Œ
# æ­¤æ—¶æˆ‘ä»¬åº”å½“ä¼˜å…ˆæœç´¢æ–¹å‘"å¾€å³ä¸‹æ–¹"çš„è·¯å¾„ï¼Œå½“æ— æ³•ä»Ž"å¾€å³ä¸‹æ–¹"çš„è·¯å¾„åˆ°è¾¾ Tï¼Œæˆ‘ä»¬å†è€ƒè™‘æœç´¢å…¶ä»–å¤§æ–¹å‘çš„è·¯å¾„ï¼š

# å¦‚ä½•è®¾è®¡è¿™æ ·å¸¦æœ‰ä¼˜å…ˆçº§çš„æœç´¢é¡ºåºï¼Œåˆ™æ˜¯ AStar ç®—æ³•ã€Œå¯å‘å¼å‡½æ•°ã€çš„è®¾è®¡è¿‡ç¨‹ï¼Œå…¶æœ¬è´¨æ˜¯å¯¹åº”äº†å¯¹ã€Œæœ€å°æ­¥æ•°ã€çš„ä¼°ç®—ï¼Œ
# åªæœ‰å½“æˆ‘ä»¬ç¡®ä¿ã€Œæœ€å°æ­¥æ•°ä¼°ç®— <= å®žé™…æœ€å°æ­¥æ•°ã€ï¼ŒAStar ç®—æ³•çš„æ­£ç¡®æ€§æ‰å¾—ä»¥ä¿è¯ã€‚

# å› æ­¤æˆ‘ä»¬å¾€å¾€ä¼šç›´æŽ¥ä½¿ç”¨ã€Œç†è®ºæœ€å°æ­¥æ•°ã€æ¥ä½œä¸ºå¯å‘å¼å‡½æ•°çš„ï¼Œå¯¹äºŽæœ¬é¢˜ï¼Œå¯ç›´æŽ¥ä½¿ç”¨ã€Œæ›¼å“ˆé¡¿è·ç¦»ã€ä½œä¸ºã€Œç†è®ºæœ€å°æ­¥æ•°ã€ã€‚

# å› æ­¤ï¼Œå¦‚æžœæˆ‘ä»¬æ˜¯è¦ä»Žæºç‚¹ S åˆ°æ±‡ç‚¹ Tï¼Œå¹¶ä¸”å½“å‰ä½äºŽä¸­é€”ç‚¹ x çš„è¯ï¼Œç‚¹ x çš„æœ€å°æ­¥æ•°ä¼°ç®—åŒ…æ‹¬ä¸¤éƒ¨åˆ†ï¼š
# åˆ°ç‚¹ x çš„å®žé™…æ­¥æ•° + ä»Žç‚¹ x åˆ°ç‚¹ T çš„ç†è®ºæœ€å°æ­¥æ•°ï¼ˆæ›¼å“ˆé¡¿è·ç¦»ï¼‰ã€‚
# ä½¿ç”¨ã€Œä¼˜å…ˆé˜Ÿåˆ—ã€æŒ‰ç…§ã€Œæ€»çš„æœ€å°æ­¥æ•°ä¼°ç®—ã€è¿›è¡Œå‡ºé˜Ÿï¼Œå³å¯å®žçŽ° AStar ç®—æ³•çš„æœç´¢é¡ºåºã€‚

# AStar ç®—æ³•åšè¿‡å¾ˆå¤šæ¬¡äº†ï¼Œç›¸å…³åˆé›†å¯ä»¥åœ¨ è¿™é‡Œ çœ‹åˆ°ã€‚ å¦å¤–ï¼Œç½‘ä¸Šå¾ˆå¤šå¯¹ AStar æ­£ç¡®æ€§è¯æ˜Žä¸äº†è§£çš„äººï¼Œ
# ä¼šç¼ºå°‘ä»¥ä¸‹ map.get(nidx) > step + 1 åˆ¤æ–­é€»è¾‘ã€‚ 
# ç®€å•æ¥è¯´ï¼Œå¯å‘å¼å‡½æ•°çš„è®¾è®¡æ˜¯é’ˆå¯¹æ±‡ç‚¹è€Œè¨€çš„ï¼Œ
# å› æ­¤ AStar ç®—æ³•æœç´¢è¿‡ç¨‹åªç¡®ä¿å¯¹ T çš„å‡ºå…¥é˜Ÿæ¬¡åºèƒ½å¤Ÿå¯¹åº”å›žåˆ°ç‚¹ T ç¬¬ k çŸ­è·¯ï¼Œ
# è€Œå¯¹äºŽå…¶ä½™ç‚¹çš„å‡ºå…¥é˜Ÿæ¬¡åºåˆ°å…¶ä½™ç‚¹çš„æœ€çŸ­è·¯æ²¡æœ‰å¿…ç„¶çš„å¯¹åº”å…³ç³»ï¼Œå› æ­¤å½“æŸä¸ªç‚¹çš„æœ€å°æ­¥æ•°è¢«æ›´æ–°ï¼Œæˆ‘ä»¬æ˜¯è¦å°†å…¶è¿›è¡Œå†æ¬¡å…¥é˜Ÿçš„ã€‚

# https://keson96.github.io/2016/08/02/2016-08-02-Heuristic-Search-Methods/



# æ–¹æ³•äºŒï¼šDijkstra ç®—æ³•
# æ€è·¯ä¸Žç®—æ³•

# æˆ‘ä»¬è¿˜å¯ä»¥åˆ©ç”¨ Dijkstra ç®—æ³•æ±‚çŸ©é˜µä¸­ä¸¤ç‚¹çš„æœ€çŸ­è·ç¦»ï¼ŒDijkstra ç®—æ³•ä¹Ÿæ˜¯åˆ©ç”¨çš„å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼Œ
# ä¸åŒçš„æ˜¯ï¼Œæ¯æ¬¡å¯¹é˜Ÿåˆ—ä¸­ä¼˜å…ˆé€‰æ‹©æœ€çŸ­è·¯å¾„çš„å…ƒç´ ã€‚visited è®°å½•åœ¨æŸä¸ªæ—¶é—´ç‚¹å·²ç»æ·»åŠ åˆ°é˜Ÿåˆ—ä¸­çš„èŠ‚ç‚¹ï¼Œè¿™äº›èŠ‚ç‚¹å·²è¢«å¤„ç†æˆ–åœ¨ç­‰å¾…å¤„ç†çš„é˜Ÿåˆ—ä¸­ã€‚
# æ¯æ¬¡ä»Žé˜Ÿåˆ—ä¸­å–å‡ºå½“å‰ä»Žèµ·ç‚¹å¼€å§‹çš„æœ€å°‘æ­¥æ•°çš„ç‚¹ï¼Œå¯¹äºŽä¸‹ä¸€ä¸ªè¦å¤„ç†çš„æ¯ä¸ªèŠ‚ç‚¹ï¼ŒæŸ¥çœ‹ä»–ä»¬çš„å››ä¸ªæ–¹å‘ä¸Šç›¸é‚»çš„ç‚¹ï¼Œå¦‚æžœç›¸é‚»çš„ç‚¹æ²¡æœ‰è¢«éåŽ†è¿‡ä¸”ä¸æ˜¯éšœç¢ï¼Œ
# å°†å…¶åŠ å…¥åˆ°é˜Ÿåˆ—ä¸­ï¼Œç›´åˆ°æ‰¾åˆ°ç»ˆç‚¹ä¸ºæ­¢ï¼Œè¿”å›žå½“å‰çš„æ­¥æ•°å³å¯ã€‚æœ€ç»ˆè¿”å›žæ‰€æœ‰çš„æ­¥æ•°ä¹‹å’Œå³ä¸ºæœ€ç»ˆç»“æžœã€‚ 
# ä½¿ç”¨è¯¥ç®—æ³•éœ€è¦è€ƒè™‘çš„é—®é¢˜ï¼šç”±äºŽé¢˜ç›®ä¸­é‡åˆ°éšœç¢ç‰©æ— æ³•é€šè¡Œçš„ï¼Œå› æ­¤å½“å‰é€‰æ‹©çš„æœ€çŸ­è·¯å¾„çš„èŠ‚ç‚¹å¹¶ä¸æ˜¯æœ€ä¼˜çš„ï¼Œæ‰€ä»¥è¯¥è§£æ³•åœ¨æ­¤é¢˜ä¸­æ€§èƒ½ä¸å¤ªå¥½ã€‚


# Dijkstraç®—æ³•å’Œå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰éƒ½æ˜¯ç”¨äºŽå›¾çš„æœç´¢ç®—æ³•ï¼Œä½†å®ƒä»¬ä¹‹é—´æœ‰ä¸€äº›å…³é”®çš„åŒºåˆ«ã€‚

# å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰ æ˜¯ä¸€ç§ç”¨äºŽéåŽ†æˆ–æœç´¢æ ‘æˆ–å›¾çš„ç®—æ³•ã€‚
# åœ¨å›¾ä¸­ï¼ŒBFSä¼˜å…ˆæœç´¢å½“å‰é¡¶ç‚¹çš„æ‰€æœ‰é‚»æŽ¥é¡¶ç‚¹ï¼Œç„¶åŽå†å¯¹è¿™äº›é¡¶ç‚¹çš„é‚»æŽ¥é¡¶ç‚¹è¿›è¡Œæœç´¢ã€‚
# åœ¨BFSä¸­ï¼Œæ‰€æœ‰è¾¹çš„æƒé‡éƒ½è¢«è®¤ä¸ºæ˜¯ç›¸ç­‰çš„ã€‚


# Dijkstraç®—æ³• æ˜¯ä¸€ç§ç”¨äºŽå¯»æ‰¾ç»™å®šå›¾ä¸­çš„æœ€çŸ­è·¯å¾„çš„ç®—æ³•ã€‚ç›¸å¯¹äºŽBFSï¼ŒDijkstraç®—æ³•è€ƒè™‘äº†è¾¹çš„æƒé‡ã€‚
# å› æ­¤ï¼ŒDijkstraç®—æ³•å¯ä»¥ç”¨äºŽè§£å†³BFSæ— æ³•è§£å†³çš„é—®é¢˜ï¼Œæ¯”å¦‚å¯»æ‰¾åŠ æƒå›¾ä¸­çš„æœ€çŸ­è·¯å¾„ã€‚

# ä»¥ä¸‹æ˜¯Dijkstraç®—æ³•çš„è¯¦ç»†æ­¥éª¤ï¼š
# åˆå§‹åŒ–ï¼šé€‰æ‹©ä¸€ä¸ªæºé¡¶ç‚¹ï¼Œå°†å…¶è·ç¦»è®¾ä¸º0ã€‚å°†æ‰€æœ‰å…¶ä»–é¡¶ç‚¹çš„è·ç¦»è®¾ä¸ºæ— ç©·å¤§ï¼ˆä»£è¡¨å½“å‰æˆ‘ä»¬ä¸çŸ¥é“åˆ°è¾¾è¿™ä¸ªé¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ï¼‰ã€‚
# å¯¹äºŽæºé¡¶ç‚¹çš„æ¯ä¸ªé‚»æŽ¥ç‚¹ï¼Œæ›´æ–°å®ƒä»¬åˆ°æºé¡¶ç‚¹çš„è·ç¦»ï¼ˆå¦‚æžœæ–°çš„è·ç¦»æ›´å°çš„è¯ï¼‰ã€‚
# é€‰æ‹©ä¸€ä¸ªæœªè®¿é—®è¿‡çš„å…·æœ‰æœ€å°è·ç¦»çš„é¡¶ç‚¹ï¼Œç„¶åŽå¯¹å…¶è¿›è¡Œè®¿é—®ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬å°†â€œæ°¸ä¹…â€åœ°ç¡®å®šè¯¥é¡¶ç‚¹çš„æœ€çŸ­è·ç¦»ã€‚
# å¯¹äºŽæ–°é€‰æ‹©çš„é¡¶ç‚¹çš„æ¯ä¸ªé‚»æŽ¥ç‚¹ï¼Œæ£€æŸ¥æ˜¯å¦å¯ä»¥é€šè¿‡æ–°é€‰æ‹©çš„é¡¶ç‚¹åˆ°è¾¾é‚»æŽ¥ç‚¹çš„è·ç¦»æ›´å°ã€‚å¦‚æžœå¯ä»¥ï¼Œæ›´æ–°å®ƒä»¬çš„è·ç¦»ã€‚
# é‡å¤æ­¥éª¤3å’Œ4ï¼Œç›´åˆ°æ‰€æœ‰çš„é¡¶ç‚¹éƒ½è¢«è®¿é—®è¿‡ã€‚æœ€åŽçš„ç»“æžœå°±æ˜¯æºé¡¶ç‚¹åˆ°æ‰€æœ‰å…¶ä»–é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ã€‚

# ä¸¾ä¸ªä¾‹å­ï¼Œå‡è®¾æˆ‘ä»¬æœ‰ä»¥ä¸‹çš„å›¾ï¼Œé¡¶ç‚¹Aæ˜¯æºé¡¶ç‚¹ã€‚
#     A
#    / \
#  1/   \5
#  /     \
# B-------C
#    2

# è¿™ä¸ªå›¾ä¸­æœ‰ä¸‰ä¸ªé¡¶ç‚¹ï¼ˆAï¼ŒBï¼ŒCï¼‰å’Œä¸‰æ¡è¾¹ï¼Œæ¯æ¡è¾¹çš„æƒé‡åˆ†åˆ«ä¸º1ï¼Œ5å’Œ2ã€‚

# é¦–å…ˆï¼Œæˆ‘ä»¬å°†é¡¶ç‚¹Açš„è·ç¦»è®¾ä¸º0ï¼Œå°†é¡¶ç‚¹Bå’ŒCçš„è·ç¦»è®¾ä¸ºæ— ç©·å¤§ã€‚ç„¶åŽï¼Œæˆ‘ä»¬æ›´æ–°é¡¶ç‚¹Bå’ŒCçš„è·ç¦»ï¼Œå˜ä¸º1ï¼ˆA-Bï¼‰å’Œ5ï¼ˆA-Cï¼‰ã€‚
# æŽ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬é€‰æ‹©è·ç¦»æœ€å°çš„æœªè®¿é—®è¿‡çš„é¡¶ç‚¹ï¼Œä¹Ÿå°±æ˜¯é¡¶ç‚¹Bï¼Œç„¶åŽæ›´æ–°Bçš„é‚»æŽ¥ç‚¹ï¼ˆé¡¶ç‚¹Cï¼‰çš„è·ç¦»ã€‚
# å› ä¸ºé€šè¿‡Båˆ°Cçš„è·ç¦»ï¼ˆ1+2=3ï¼‰å°äºŽç›´æŽ¥ä»ŽAåˆ°Cçš„è·ç¦»ï¼ˆ5ï¼‰ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†Cçš„è·ç¦»æ›´æ–°ä¸º3ã€‚
# æœ€åŽï¼Œæˆ‘ä»¬è®¿é—®æœ€åŽä¸€ä¸ªæœªè®¿é—®è¿‡çš„é¡¶ç‚¹Cã€‚è¿™æ ·æˆ‘ä»¬å°±æ‰¾åˆ°äº†ä»ŽAåˆ°Bå’ŒCçš„æœ€çŸ­è·¯å¾„ï¼Œåˆ†åˆ«ä¸º1å’Œ3ã€‚

import heapq

def dijkstra(graph, start):
    distances = {node: float('infinity') for node in graph}
    distances[start] = 0
    queue = [(0, start)]

    while queue:
        current_distance, current_node = heapq.heappop(queue)

        if current_distance > distances[current_node]:
            continue

        for neighbor, weight in graph[current_node].items():
            distance = current_distance + weight

            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(queue, (distance, neighbor))

    return distances

# ç¤ºä¾‹å›¾
graph = {
    'A': {'B': 1, 'C': 5},
    'B': {'A': 1, 'C': 2},
    'C': {'B': 2, 'A': 5}
}

print(dijkstra(graph, 'A'))  # è¾“å‡ºï¼š{'A': 0, 'B': 1, 'C': 3}

# heapq.heappush(heap, item)
# å°† item çš„å€¼åŠ å…¥ heap ä¸­ï¼Œä¿æŒå †çš„ä¸å˜æ€§ã€‚

# heapq.heappop(heap)
# å¼¹å‡ºå¹¶è¿”å›ž heap çš„æœ€å°çš„å…ƒç´ ï¼Œä¿æŒå †çš„ä¸å˜æ€§ã€‚å¦‚æžœå †ä¸ºç©ºï¼ŒæŠ›å‡º IndexError ã€‚ä½¿ç”¨ heap[0] ï¼Œå¯ä»¥åªè®¿é—®æœ€å°çš„å…ƒç´ è€Œä¸å¼¹å‡ºå®ƒã€‚